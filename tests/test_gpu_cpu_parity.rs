#[cfg(feature = "gpu")]
#[cfg(test)]
mod tests {
    use anyhow::Result;
    use entropy_lab_rs::scans::gpu_solver::GpuSolver;
    use entropy_lab_rs::scans::milk_sad;
    use entropy_lab_rs::utils::electrum;
    use bitcoin::{Address, Network, CompressedPublicKey};
    use bitcoin::secp256k1::{Secp256k1, SecretKey};
    use bitcoin::bip32::{DerivationPath, Xpriv};
    use std::str::FromStr;
    use bip39::Mnemonic;

    #[test]
    fn test_milk_sad_gpu_cpu_parity() -> Result<()> {
        println!("\n=== Testing Milk Sad GPU/CPU Parity ===");
        
        let timestamp = 1500000000u32;
        let start_ts = timestamp;
        let end_ts = timestamp + 1;

        // 1. Run CPU Implementation
        // Note: milk_sad::generate_milk_sad_entropy is private, but run() uses it.
        // We will simulate the CPU logic here using publicly available components or similar logic if private.
        // Actually, we can check if we can make it public or duplicate logic here for independent verification.
        // Duplicate logic is better for independent testing.

        // CPU Logic: MT19937 -> Entropy -> Mnemonic -> Seed -> Address
        // Re-implementing simplified CPU flow here to strictly reference against the GPU results.
        use rand_mt::Mt19937GenRand32;
        
        // A. Generate Entropy
        let mut rng = Mt19937GenRand32::new(timestamp);
        let mut entropy = [0u8; 16];
        for i in 0..4 {
            let val = rng.next_u32();
            entropy[i * 4] = ((val >> 24) & 0xFF) as u8;
            entropy[i * 4 + 1] = ((val >> 16) & 0xFF) as u8;
            entropy[i * 4 + 2] = ((val >> 8) & 0xFF) as u8;
            entropy[i * 4 + 3] = (val & 0xFF) as u8;
        }
        
        // B. Derive Address (Index 0)
        let mnemonic = Mnemonic::from_entropy(&entropy)?;
        let seed = mnemonic.to_seed("");
        let network = Network::Bitcoin;
        let secp = Secp256k1::new();
        let root = Xpriv::new_master(network, &seed)?;
        let path = DerivationPath::from_str("m/44'/0'/0'/0/0")?;
        let child = root.derive_priv(&secp, &path)?;
        let pubkey = child.to_keypair(&secp).public_key();
        let cpu_address = Address::p2pkh(&bitcoin::PublicKey::new(pubkey), network);

        println!("Timestamp: {}", timestamp);
        println!("CPU Address: {}", cpu_address);

        // 2. Run GPU Implementation
        let solver = GpuSolver::new()?;
        // GPU computes hash160. Let's get hash160 from CPU address.
        // Actually, solver.compute_milk_sad_crack takes a target hash160 and returns matching timestamps.
        // So we give it the CPU address's hash.
        
        // v0.32: Manual Hash160 extraction from P2PKH script
        let script = cpu_address.script_pubkey();
        let target_hash160_slice = &script.as_bytes()[3..23];
        let mut target_hash_array = [0u8; 20];
        target_hash_array.copy_from_slice(target_hash160_slice);

        // Run GPU search for JUST this timestamp
        let results = solver.compute_milk_sad_crack(start_ts, end_ts, &target_hash_array)?;
        
        println!("GPU Results: {:?}", results);

        // 3. Compare
        assert!(!results.is_empty(), "GPU failed to find the address generated by CPU");
        assert_eq!(results[0], timestamp as u64, "GPU found wrong timestamp");
        assert_eq!(results.len(), 1, "GPU found explicit duplicates?");

        println!("✓ Milk Sad Parity Passed");
        Ok(())
    }

    #[test]
    fn test_cake_wallet_electrum_gpu_cpu_parity() -> Result<()> {
        println!("\n=== Testing Cake Wallet Electrum GPU/CPU Parity ===");
        
        // 1. Setup Test Vector
        // Use a simple entropy seed
        let test_entropy = [0xABu8; 16]; // Deterministic pattern
        
        // 2. CPU Implementation (Electrum)
        let mnemonic = Mnemonic::from_entropy(&test_entropy)?;
        let mnemonic_str = mnemonic.to_string();
        
        // Use the util we want to test parity against
        let seed = electrum::mnemonic_to_seed(&mnemonic_str);
        
        let network = Network::Bitcoin;
        let secp = Secp256k1::new();
        let root = Xpriv::new_master(network, &seed)?;
        
        // Cake Wallet path: m/0'/0/0 (Purpose 0 in our kernels)
        let path = DerivationPath::from_str("m/0'/0/0")?;
        let child = root.derive_priv(&secp, &path)?;
        let pubkey = child.to_keypair(&secp).public_key();
        let compressed_pubkey = CompressedPublicKey(pubkey);
        let cpu_address = Address::p2wpkh(&compressed_pubkey, network);
        
        println!("Test Entropy: {}", hex::encode(&test_entropy));
        println!("CPU Address: {}", cpu_address);

        // 3. GPU Implementation
        let solver = GpuSolver::new()?;
        
        // We need to pass [u8; 16] entropies to compute_batch_electrum
        let entropies = vec![test_entropy];
        // Purpose 0 = m/0'/0/0
        let gpu_raw_addresses = solver.compute_batch_electrum(&entropies, 0)?;
        
        assert_eq!(gpu_raw_addresses.len(), 1);
        let gpu_addr_bytes = gpu_raw_addresses[0];
        
        // Decode GPU address (it returns raw bytes, usually P2WPKH witness program in first 20 bytes)
        // Check `decode_address_from_gpu` logic in `cake_wallet_rpc.rs` or `gpu_solver.rs`
        // Inspecting gpu_solver.rs, `compute_batch_electrum` returns `Vec<[u8; 25]>`.
        // For P2WPKH (SegWit), the first 20 bytes are the witness program (Hash160 of pubkey).
        
        let gpu_witness_program = &gpu_addr_bytes[0..20];
        
        // Convert CPU address to witness program for comparison
        let cpu_witness_program = cpu_address.witness_program().unwrap();
        // cpu_witness_program is Version + Program. We just want the program bytes.
        let cpu_prog_bytes = cpu_witness_program.program().as_bytes();
        
        println!("CPU Witness: {}", hex::encode(cpu_prog_bytes));
        println!("GPU Witness: {}", hex::encode(gpu_witness_program));
        
        assert_eq!(gpu_witness_program, cpu_prog_bytes, "GPU witness program does not match CPU");
        
        // Also verify full address reconstruction matches
        println!("✓ Cake Wallet Electrum Parity Passed");
        
        Ok(())
    }
}
