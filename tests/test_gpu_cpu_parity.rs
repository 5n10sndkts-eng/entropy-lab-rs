#[cfg(feature = "gpu")]
#[cfg(test)]
mod tests {
    use anyhow::Result;
    use bip39::Mnemonic;
    use bitcoin::bip32::{DerivationPath, Xpriv};
    use bitcoin::secp256k1::{Secp256k1, SecretKey};
    use bitcoin::{Address, CompressedPublicKey, Network};
    use temporal_planetarium_lib::scans::gpu_solver::GpuSolver;
    use temporal_planetarium_lib::scans::milk_sad;
    use temporal_planetarium_lib::utils::electrum;
    use std::str::FromStr;

    #[test]
    fn test_milk_sad_gpu_cpu_parity() -> Result<()> {
        println!("\n=== Testing Milk Sad GPU/CPU Parity ===");

        let timestamp = 1500000000u32;
        let start_ts = timestamp;
        let end_ts = timestamp + 1;

        // 1. Run CPU Implementation
        // Note: milk_sad::generate_milk_sad_entropy is private, but run() uses it.
        // We will simulate the CPU logic here using publicly available components or similar logic if private.
        // Actually, we can check if we can make it public or duplicate logic here for independent verification.
        // Duplicate logic is better for independent testing.

        // CPU Logic: MT19937 -> Entropy -> Mnemonic -> Seed -> Address
        // Re-implementing simplified CPU flow here to strictly reference against the GPU results.
        use rand_mt::Mt19937GenRand32;

        // A. Generate Entropy
        let mut rng = Mt19937GenRand32::new(timestamp);
        let mut entropy = [0u8; 16];
        for i in 0..4 {
            let val = rng.next_u32();
            entropy[i * 4] = ((val >> 24) & 0xFF) as u8;
            entropy[i * 4 + 1] = ((val >> 16) & 0xFF) as u8;
            entropy[i * 4 + 2] = ((val >> 8) & 0xFF) as u8;
            entropy[i * 4 + 3] = (val & 0xFF) as u8;
        }

        // B. Derive Address (Index 0)
        let mnemonic = Mnemonic::from_entropy(&entropy)?;
        let seed = mnemonic.to_seed("");
        let network = Network::Bitcoin;
        let secp = Secp256k1::new();
        let root = Xpriv::new_master(network, &seed)?;
        let path = DerivationPath::from_str("m/44'/0'/0'/0/0")?;
        let child = root.derive_priv(&secp, &path)?;
        let pubkey = child.to_keypair(&secp).public_key();
        let cpu_address = Address::p2pkh(&bitcoin::PublicKey::new(pubkey), network);

        println!("Timestamp: {}", timestamp);
        println!("CPU Address: {}", cpu_address);

        // 2. Run GPU Implementation
        let solver = GpuSolver::new()?;
        // GPU computes hash160. Let's get hash160 from CPU address.
        // Actually, solver.compute_milk_sad_crack takes a target hash160 and returns matching timestamps.
        // So we give it the CPU address's hash.

        // v0.32: Manual Hash160 extraction from P2PKH script
        let script = cpu_address.script_pubkey();
        let target_hash160_slice = &script.as_bytes()[3..23];
        let mut target_hash_array = [0u8; 20];
        target_hash_array.copy_from_slice(target_hash160_slice);

        // Run GPU search for JUST this timestamp
        let results = solver.compute_milk_sad_crack(start_ts, end_ts, &target_hash_array)?;

        println!("GPU Results: {:?}", results);

        // 3. Compare
        assert!(
            !results.is_empty(),
            "GPU failed to find the address generated by CPU"
        );
        assert_eq!(results[0], timestamp as u64, "GPU found wrong timestamp");
        assert_eq!(results.len(), 1, "GPU found explicit duplicates?");

        println!("✓ Milk Sad Parity Passed");
        Ok(())
    }

    #[test]
    fn test_cake_wallet_electrum_gpu_cpu_parity() -> Result<()> {
        println!("\n=== Testing Cake Wallet Electrum GPU/CPU Parity ===");

        // 1. Setup Test Vector
        // Use a simple entropy seed
        let test_entropy = [0xABu8; 16]; // Deterministic pattern

        // 2. CPU Implementation (Electrum)
        let mnemonic = Mnemonic::from_entropy(&test_entropy)?;
        let mnemonic_str = mnemonic.to_string();

        // Use the util we want to test parity against
        let seed = electrum::mnemonic_to_seed(&mnemonic_str);

        let network = Network::Bitcoin;
        let secp = Secp256k1::new();
        let root = Xpriv::new_master(network, &seed)?;

        // Cake Wallet path: m/0'/0/0 (Purpose 0 in our kernels)
        let path = DerivationPath::from_str("m/0'/0/0")?;
        let child = root.derive_priv(&secp, &path)?;
        let pubkey = child.to_keypair(&secp).public_key();
        let compressed_pubkey = CompressedPublicKey(pubkey);
        let cpu_address = Address::p2wpkh(&compressed_pubkey, network);

        println!("Test Entropy: {}", hex::encode(&test_entropy));
        println!("CPU Address: {}", cpu_address);

        // 3. GPU Implementation
        let solver = GpuSolver::new()?;

        // We need to pass [u8; 16] entropies to compute_batch_electrum
        let entropies = vec![test_entropy];
        // Purpose 0 = m/0'/0/0
        let gpu_raw_addresses = solver.compute_batch_electrum(&entropies, 0)?;

        assert_eq!(gpu_raw_addresses.len(), 1);
        let gpu_addr_bytes = gpu_raw_addresses[0];

        // Decode GPU address (it returns raw bytes, usually P2WPKH witness program in first 20 bytes)
        // Check `decode_address_from_gpu` logic in `cake_wallet_rpc.rs` or `gpu_solver.rs`
        // Inspecting gpu_solver.rs, `compute_batch_electrum` returns `Vec<[u8; 25]>`.
        // For P2WPKH (SegWit), the first 20 bytes are the witness program (Hash160 of pubkey).

        let gpu_witness_program = &gpu_addr_bytes[0..20];

        // Convert CPU address to witness program for comparison
        let cpu_witness_program = cpu_address.witness_program().unwrap();
        // cpu_witness_program is Version + Program. We just want the program bytes.
        let cpu_prog_bytes = cpu_witness_program.program().as_bytes();

        println!("CPU Witness: {}", hex::encode(cpu_prog_bytes));
        println!("GPU Witness: {}", hex::encode(gpu_witness_program));

        assert_eq!(
            gpu_witness_program, cpu_prog_bytes,
            "GPU witness program does not match CPU"
        );

        // Also verify full address reconstruction matches
        println!("✓ Cake Wallet Electrum Parity Passed");

        Ok(())
    }

    #[test]
    fn test_optimized_kernel_vs_standard() -> Result<()> {
        println!("\n=== Testing Optimized Kernel vs Standard Kernel ===");

        let solver = GpuSolver::new()?;

        // Test with a few random entropies
        let test_entropies = vec![
            [
                0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54,
                0x32, 0x10,
            ],
            [
                0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
                0x22, 0x22,
            ],
            [
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00,
            ],
        ];

        // Test both BIP44 (purpose=44) and Cake Wallet (purpose=0)
        for purpose in [44, 0] {
            println!("\n--- Testing purpose={} ---", purpose);

            // Generate addresses with standard kernel
            let standard_results = solver.compute_batch(&test_entropies, purpose)?;
            println!(
                "Standard kernel: {} addresses generated",
                standard_results.len()
            );

            // Generate addresses with optimized kernel
            let optimized_results = solver.compute_batch_optimized(&test_entropies, purpose)?;
            println!(
                "Optimized kernel: {} addresses generated",
                optimized_results.len()
            );

            // Compare results
            assert_eq!(
                standard_results.len(),
                optimized_results.len(),
                "Kernel result count mismatch for purpose={}",
                purpose
            );

            for (i, (std_addr, opt_addr)) in standard_results
                .iter()
                .zip(optimized_results.iter())
                .enumerate()
            {
                assert_eq!(
                    std_addr, opt_addr,
                    "Address mismatch at index {} for purpose={}: standard={:?} != optimized={:?}",
                    i, purpose, std_addr, opt_addr
                );
                println!("  ✓ Address {} matches", i);
            }

            println!(
                "✓ All {} addresses match for purpose={}",
                test_entropies.len(),
                purpose
            );
        }

        println!("\n✓ Optimized kernel produces identical results to standard kernel");
        Ok(())
    }

    #[test]
    fn test_optimized_kernel_large_batch() -> Result<()> {
        println!("\n=== Testing Optimized Kernel with Large Batch ===");

        let solver = GpuSolver::new()?;

        // Generate larger batch to test performance and correctness
        let batch_size = 100;
        let mut test_entropies = Vec::new();

        for i in 0..batch_size {
            let mut entropy = [0u8; 16];
            // Create semi-random but deterministic entropies
            for j in 0..16 {
                entropy[j] = ((i * 16 + j) % 256) as u8;
            }
            test_entropies.push(entropy);
        }

        let purpose = 44; // BIP44

        println!("Testing with {} entropies...", batch_size);

        // Standard kernel
        let start = std::time::Instant::now();
        let standard_results = solver.compute_batch(&test_entropies, purpose)?;
        let standard_duration = start.elapsed();
        println!("Standard kernel: {:?}", standard_duration);

        // Optimized kernel
        let start = std::time::Instant::now();
        let optimized_results = solver.compute_batch_optimized(&test_entropies, purpose)?;
        let optimized_duration = start.elapsed();
        println!("Optimized kernel: {:?}", optimized_duration);

        // Compare
        assert_eq!(standard_results.len(), batch_size);
        assert_eq!(optimized_results.len(), batch_size);

        for (i, (std_addr, opt_addr)) in standard_results
            .iter()
            .zip(optimized_results.iter())
            .enumerate()
        {
            assert_eq!(std_addr, opt_addr, "Address mismatch at index {}", i);
        }

        println!("✓ All {} addresses match", batch_size);
        println!("Performance comparison:");
        println!("  Standard: {:?}", standard_duration);
        println!("  Optimized: {:?}", optimized_duration);

        if optimized_duration < standard_duration {
            let speedup = standard_duration.as_secs_f64() / optimized_duration.as_secs_f64();
            println!("  Speedup: {:.2}x faster", speedup);
        } else {
            println!(
                "  Note: Optimized kernel may need larger batches to show performance benefit"
            );
        }

        Ok(())
    }
}
